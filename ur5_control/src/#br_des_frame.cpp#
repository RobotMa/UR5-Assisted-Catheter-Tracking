#include <ros/ros.h>
#include <Eigen/Core>
#include <Eigen/Dense>
#include <unsupported/Eigen/MatrixFunctions>

#include <vector>
#include <algorithm>

#include <tf/transform_listener.h>
#include <tf/transform_datatypes.h>

#include <tf_conversions/tf_eigen.h>

#include <ur_kinematics/ur_kin.h>

#include <std_msgs/Bool.h>
#include <sensor_msgs/JointState.h>
#include <trajectory_msgs/JointTrajectory.h>
#include <actionlib/client/simple_action_client.h>
#include <control_msgs/FollowJointTrajectoryAction.h>
#include <geometry_msgs/Point.h>
#include <geometry_msgs/Pose.h>


void callback( ) {

}

int main( int argc, char** argv ){

    // Initialize ROS node "trajectory"
    ros::init( argc, argv, "trajectory" );

    // Create a node handle
    ros::NodeHandle nh;

    // publishing joint trajectory
    std::string published_topic_name( "/joint_trajectory" );

    // Create a publisher that will publish joint states on the topic
    // /joint_states

    // The publisher will publish to /joint_trajectory at the end of
    // of the main function after completing all the computation.
    // The size of publishing queue is 1 which means it will only buffer
    // up 1 message. The old message will be thrown away immediately
    // if a new one is received
    ros::Publisher pub_jointstate;
    pub_jointstate = nh.advertise<sensor_msgs::JointState>( published_topic_name, 1 );

    // Create a subscriber that will receive 6D setposes
    ros::Subscriber sub_setpose;
    sub_setpose = nh.subscribe( "setpose", 1, callback );
